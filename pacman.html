<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>小精靈：手機/電腦平衡版</title>
    <style>
        body {
            background-color: #0d0d0d; color: white; display: flex; flex-direction: column;
            align-items: center; justify-content: center; height: 100vh; margin: 0;
            font-family: '微軟正黑體', sans-serif; overflow: hidden;
            touch-action: none; /* 防止手機瀏覽器預設的縮放與滾動 */
        }
        #ui { margin-bottom: 10px; display: flex; gap: 15px; font-size: 18px; font-weight: bold; color: #FFEB3B; }
        .stat-box { background: rgba(255,255,255,0.1); padding: 5px 10px; border-radius: 10px; border: 1px solid #333; }
        canvas { 
            border: 4px solid #1919A6; background-color: black; 
            box-shadow: 0 0 20px rgba(25, 25, 166, 0.4);
            max-width: 95vw; max-height: 70vh; /* 適應手機螢幕大小 */
        }
        #overlay {
            position: absolute; display: none; background: rgba(0,0,0,0.95); padding: 30px;
            border: 3px solid #FFEB3B; text-align: center; z-index: 100; border-radius: 20px;
            width: 80%;
        }
        button {
            background: #FFEB3B; border: none; padding: 12px 30px; cursor: pointer;
            font-weight: bold; font-size: 20px; margin-top: 20px; border-radius: 8px;
        }
        .hint { margin-top: 10px; color: #888; font-size: 12px; text-align: center; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stat-box">LV: <span id="levelText">1</span></div>
        <div class="stat-box">SCORE: <span id="scoreText">0</span></div>
        <div class="stat-box">LIVES: <span id="livesText">3</span></div>
    </div>
    
    <div style="position: relative;">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h2 id="statusTitle">LEVEL CLEAR</h2>
            <p id="statusDesc">準備好挑戰下一關了嗎？</p>
            <button id="actionBtn" onclick="nextLevelOrRestart()">點擊繼續</button>
        </div>
    </div>

    <div class="hint">電腦用方向鍵 • 手機請在螢幕上「滑動」控制方向</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreText = document.getElementById('scoreText');
        const levelText = document.getElementById('levelText');
        const livesText = document.getElementById('livesText');
        const overlay = document.getElementById('overlay');
        const statusTitle = document.getElementById('statusTitle');
        const statusDesc = document.getElementById('statusDesc');

        const TILE = 20;     
        const PACMAN_SPEED = 2; 

        // 沿用您的地圖數據
        const allLevels = [
            [ [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,1],[1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,1,0,0,0,1,2,2,2,1,0,0,0,0,1],[1,1,1,1,0,1,1,1,2,2,2,1,1,1,0,1,1,1,1],[2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],[1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],[1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[1,3,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,3,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] ],
            [ [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,1],[1,3,1,0,1,0,1,1,1,2,1,1,1,0,1,0,1,3,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1],[1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,0,1],[1,0,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1],[1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,1],[1,3,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,3,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] ]
        ];

        let currentLevelIndex = 0;
        let map = [];
        let totalScore = 0;
        let levelScore = 0;
        let lives = 3;
        let respawnTimer = 0;
        let isGameOver = false;
        let pacman, ghosts;
        let powerModeTimer = 0;
        let milestoneReached = 0;

        // --- 手機滑動感應邏輯 ---
        let touchStartX = 0;
        let touchStartY = 0;

        window.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);

        window.addEventListener('touchend', e => {
            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            handleSwipe(touchEndX - touchStartX, touchEndY - touchStartY);
        }, false);

        function handleSwipe(dx, dy) {
            if (Math.abs(dx) > Math.abs(dy)) {
                // 水平滑動
                if (dx > 30) { pacman.reqX = 1; pacman.reqY = 0; }
                else if (dx < -30) { pacman.reqX = -1; pacman.reqY = 0; }
            } else {
                // 垂直滑動
                if (dy > 30) { pacman.reqX = 0; pacman.reqY = 1; }
                else if (dy < -30) { pacman.reqX = 0; pacman.reqY = -1; }
            }
        }

        // --- 鍵盤控制 (電腦) ---
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp')    { pacman.reqX = 0; pacman.reqY = -1; }
            if (e.key === 'ArrowDown')  { pacman.reqX = 0; pacman.reqY = 1; }
            if (e.key === 'ArrowLeft')  { pacman.reqX = -1; pacman.reqY = 0; }
            if (e.key === 'ArrowRight') { pacman.reqX = 1; pacman.reqY = 0; }
        });

        function initLevel(index) {
            map = JSON.parse(JSON.stringify(allLevels[index % allLevels.length]));
            canvas.width = map[0].length * TILE;
            canvas.height = map.length * TILE;
            
            let ghostSpeed = 2 + (index * 0.15);
            pacman = { x: TILE, y: TILE, dirX: 0, dirY: 0, reqX: 0, reqY: 0 };
            ghosts = [{ x: 9 * TILE, y: 5 * TILE, dirX: 0, dirY: -1, color: '#FF0000', baseColor: '#FF0000', speed: ghostSpeed, isScared: false }];
            
            levelScore = 0; milestoneReached = 0; powerModeTimer = 0; respawnTimer = 0;
            lives = 3; livesText.innerText = lives;
            levelText.innerText = index + 1;
            isGameOver = false; overlay.style.display = 'none';
        }

        function isWall(px, py) {
            const gx = Math.floor(px / TILE), gy = Math.floor(py / TILE);
            if (gy < 0 || gy >= map.length || gx < 0 || gx >= map[0].length) return true;
            return map[gy][gx] === 1;
        }

        function update() {
            if (isGameOver) return;
            if (powerModeTimer > 0) { powerModeTimer--; if (powerModeTimer === 0) ghosts.forEach(g => g.isScared = false); }
            if (respawnTimer > 0) respawnTimer--;

            // 小精靈移動邏輯
            if (pacman.x % TILE === 0 && pacman.y % TILE === 0) {
                const gx = pacman.x / TILE, gy = pacman.y / TILE;
                if (map[gy][gx] === 0) { map[gy][gx] = 2; totalScore += 10; levelScore += 10; }
                else if (map[gy][gx] === 3) { map[gy][gx] = 2; totalScore += 50; levelScore += 50; powerModeTimer = 400; ghosts.forEach(g => g.isScared = true); }
                scoreText.innerText = totalScore;

                if (!isWall(pacman.x + pacman.reqX * TILE, pacman.y + pacman.reqY * TILE)) {
                    pacman.dirX = pacman.reqX; pacman.dirY = pacman.reqY;
                }
                if (isWall(pacman.x + pacman.dirX * TILE, pacman.y + pacman.dirY * TILE)) {
                    pacman.dirX = 0; pacman.dirY = 0;
                }
            }
            pacman.x += pacman.dirX * PACMAN_SPEED;
            pacman.y += pacman.dirY * PACMAN_SPEED;

            // 幽靈邏輯 (後援幽靈減速)
            ghosts.forEach(g => {
                let s = g.isScared ? g.speed / 2 : g.speed;
                if (Math.abs(g.x % TILE) < s && Math.abs(g.y % TILE) < s) {
                    g.x = Math.round(g.x / TILE) * TILE; g.y = Math.round(g.y / TILE) * TILE;
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    let possible = dirs.filter(d => !isWall(g.x + d.x * TILE, g.y + d.y * TILE));
                    const pick = possible[Math.floor(Math.random() * possible.length)];
                    if (pick) { g.dirX = pick.x; g.dirY = pick.y; }
                }
                g.x += g.dirX * s; g.y += g.dirY * s;

                if (Math.hypot(pacman.x - g.x, pacman.y - g.y) < TILE * 0.75) {
                    if (g.isScared) { g.x = 9 * TILE; g.y = 5 * TILE; g.isScared = false; totalScore += 200; }
                    else if (respawnTimer === 0) {
                        lives--; livesText.innerText = lives;
                        if (lives <= 0) endGame(false);
                        else { pacman.x = TILE; pacman.y = TILE; pacman.dirX = 0; pacman.dirY = 0; respawnTimer = 120; }
                    }
                }
            });

            if (levelScore >= 300 && milestoneReached < 300) { addGhost('#FFB8FF'); milestoneReached = 300; }
            if (levelScore >= 600 && milestoneReached < 600) { addGhost('#00FFFF'); milestoneReached = 600; }
            if (!map.some(row => row.includes(0)) && !map.some(row => row.includes(3))) endGame(true);
        }

        function addGhost(color) {
            let ghostSpeed = (2 + (currentLevelIndex * 0.15)) * 0.8;
            ghosts.push({ x: 9 * TILE, y: 5 * TILE, dirX: 1, dirY: 0, color: color, baseColor: color, speed: ghostSpeed, isScared: false });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 繪製地圖、豆子與幽靈... (與先前代碼相同)
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[r].length; c++) {
                    if (map[r][c] === 1) { ctx.fillStyle = '#1919A6'; ctx.fillRect(c * TILE + 2, r * TILE + 2, TILE - 4, TILE - 4); }
                    else if (map[r][c] === 0) { ctx.fillStyle = '#FFB8AE'; ctx.beginPath(); ctx.arc(c * TILE + TILE/2, r * TILE + TILE/2, 2.5, 0, Math.PI*2); ctx.fill(); }
                }
            }
            ghosts.forEach(g => {
                ctx.fillStyle = g.isScared ? '#2121FF' : g.baseColor;
                ctx.beginPath(); ctx.arc(g.x + TILE/2, g.y + TILE/2, TILE/2 - 2, 0, Math.PI*2); ctx.fill();
            });
            if (respawnTimer % 10 < 5) {
                ctx.fillStyle = '#FFEB3B'; ctx.beginPath(); ctx.arc(pacman.x + TILE/2, pacman.y + TILE/2, TILE/2 - 1, 0.2, Math.PI*2 - 0.2); ctx.fill();
            }
        }

        function endGame(win) {
            isGameOver = true;
            statusTitle.innerText = win ? "LEVEL CLEAR!" : "GAME OVER";
            statusDesc.innerText = win ? "挑戰下一關吧！" : "再試一次吧！";
            overlay.style.display = 'block';
        }

        function nextLevelOrRestart() {
            if (statusTitle.innerText === "GAME OVER") { totalScore = 0; currentLevelIndex = 0; }
            else { currentLevelIndex++; }
            initLevel(currentLevelIndex);
        }

        initLevel(0);
        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        gameLoop();
    </script>
</body>
</html>
