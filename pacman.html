<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>小精靈：五關大挑戰</title>
    <style>
        body {
            background-color: #000;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: '微軟正黑體', sans-serif;
            overflow: hidden;
        }
        #ui { margin-bottom: 10px; font-size: 24px; font-weight: bold; color: #FFEB3B; }
        .stats { display: flex; gap: 30px; }
        canvas {
            border: 4px solid #1919A6;
            background-color: black;
            box-shadow: 0 0 20px rgba(25, 25, 166, 0.5);
        }
        #overlay {
            position: absolute;
            display: none;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 2px solid #FFEB3B;
            text-align: center;
            z-index: 100;
        }
        button {
            background: #FFEB3B; border: none; padding: 10px 20px;
            cursor: pointer; font-weight: bold; margin-top: 15px; border-radius: 5px;
        }
        .hint { margin-top: 10px; color: #00FFFF; font-size: 14px; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stats">
            <div>LEVEL: <span id="levelText">1</span></div>
            <div>SCORE: <span id="scoreText">0</span></div>
        </div>
    </div>
    
    <div style="position: relative;">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h2 id="statusTitle">NEXT LEVEL</h2>
            <button id="actionBtn" onclick="nextLevelOrRestart()">繼續下一關</button>
        </div>
    </div>

    <div class="hint">吃光所有豆子進入下一關 | 300分與500分會增加幽靈</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreText = document.getElementById('scoreText');
        const levelText = document.getElementById('levelText');
        const overlay = document.getElementById('overlay');
        const statusTitle = document.getElementById('statusTitle');
        const actionBtn = document.getElementById('actionBtn');

        const TILE = 20;     
        const SPEED = 2; 

        // 1=牆, 0=豆子, 2=空地, 3=威力豆子
        const allLevels = [
            // Level 1: 經典版
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,3,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,1],
                [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,1,2,2,2,1,0,0,0,0,1],
                [1,1,1,1,0,1,1,1,2,2,2,1,1,1,0,1,1,1,1],
                [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
                [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
                [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,3,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,3,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 2: 十字路口
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,1],
                [1,3,1,0,1,0,1,1,1,2,1,1,1,0,1,0,1,3,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,0,1],
                [1,0,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,0,1],
                [1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1],
                [1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,1],
                [1,3,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,3,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 3: 窄巷密室
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,3,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,3,1],
                [1,1,0,1,0,1,1,1,1,2,1,1,1,1,0,1,0,1,1],
                [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,0,1,0,1,1,2,1,1,0,1,0,1,1,0,1],
                [1,0,1,1,0,0,0,1,2,2,2,1,0,0,0,1,1,0,1],
                [1,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1],
                [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
                [1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1],
                [1,3,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,3,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 4: 圓環結構
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,3,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,3,1],
                [1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1],
                [1,0,1,0,1,1,1,1,2,2,2,1,1,1,1,0,1,0,1],
                [1,0,1,0,1,2,2,2,2,2,2,2,2,2,1,0,1,0,1],
                [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
                [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
                [1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            // Level 5: 終極迷宮
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,3,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,3,1],
                [1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1],
                [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
                [1,0,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,0,1],
                [1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
                [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
                [1,0,0,0,0,0,0,1,3,0,3,1,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ]
        ];

        let currentLevelIndex = 0;
        let map = [];
        let score = 0;
        let isGameOver = false;
        let milestoneReached = 0;
        let powerModeTimer = 0;
        let pacman, ghosts;

        function initLevel(index) {
            // 深拷貝地圖
            map = JSON.parse(JSON.stringify(allLevels[index]));
            canvas.width = map[0].length * TILE;
            canvas.height = map.length * TILE;
            
            // 重置小精靈位置 (尋找第一個空地或豆子)
            pacman = { x: TILE, y: TILE, dirX: 0, dirY: 0, reqX: 0, reqY: 0 };
            
            // 重置幽靈
            ghosts = [
                { x: 9 * TILE, y: 5 * TILE, dirX: 0, dirY: -1, color: '#FF0000', baseColor: '#FF0000', speed: 2, isScared: false }
            ];
            
            milestoneReached = 0;
            powerModeTimer = 0;
            levelText.innerText = index + 1;
            isGameOver = false;
            overlay.style.display = 'none';
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp')    { pacman.reqX = 0; pacman.reqY = -1; }
            if (e.key === 'ArrowDown')  { pacman.reqX = 0; pacman.reqY = 1; }
            if (e.key === 'ArrowLeft')  { pacman.reqX = -1; pacman.reqY = 0; }
            if (e.key === 'ArrowRight') { pacman.reqX = 1; pacman.reqY = 0; }
        });

        function isWall(px, py) {
            const gx = Math.floor(px / TILE);
            const gy = Math.floor(py / TILE);
            if (gy < 0 || gy >= map.length || gx < 0 || gx >= map[0].length) return true;
            return map[gy][gx] === 1;
        }

        function update() {
            if (isGameOver) return;

            if (powerModeTimer > 0) {
                powerModeTimer--;
                if (powerModeTimer === 0) ghosts.forEach(g => g.isScared = false);
            }

            // --- 小精靈 ---
            if (pacman.x % TILE === 0 && pacman.y % TILE === 0) {
                const gx = pacman.x / TILE, gy = pacman.y / TILE;
                if (map[gy][gx] === 0) {
                    map[gy][gx] = 2; score += 10; scoreText.innerText = score;
                } else if (map[gy][gx] === 3) {
                    map[gy][gx] = 2; score += 50; scoreText.innerText = score;
                    powerModeTimer = 400; ghosts.forEach(g => g.isScared = true);
                }
                
                checkGhostMilestones();

                if (!isWall(pacman.x + pacman.reqX * TILE, pacman.y + pacman.reqY * TILE)) {
                    pacman.dirX = pacman.reqX; pacman.dirY = pacman.reqY;
                }
                if (isWall(pacman.x + pacman.dirX * TILE, pacman.y + pacman.dirY * TILE)) {
                    pacman.dirX = 0; pacman.dirY = 0;
                }
            }
            pacman.x += pacman.dirX * SPEED;
            pacman.y += pacman.dirY * SPEED;

            // --- 幽靈 ---
            ghosts.forEach(g => {
                let s = g.isScared ? g.speed / 2 : g.speed;
                if (g.x % TILE === 0 && g.y % TILE === 0) {
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    let possible = dirs.filter(d => !isWall(g.x + d.x * TILE, g.y + d.y * TILE));
                    if (possible.length > 1) possible = possible.filter(d => !(d.x === -g.dirX && d.y === -g.dirY));
                    const pick = possible[Math.floor(Math.random() * possible.length)];
                    if (pick) { g.dirX = pick.x; g.dirY = pick.y; }
                }
                g.x += g.dirX * s; g.y += g.dirY * s;

                if (Math.hypot(pacman.x - g.x, pacman.y - g.y) < TILE * 0.7) {
                    if (g.isScared) {
                        g.x = 9 * TILE; g.y = 5 * TILE; g.isScared = false; score += 200; scoreText.innerText = score;
                    } else {
                        endGame(false);
                    }
                }
            });

            // 檢查過關
            if (!map.some(row => row.includes(0)) && !map.some(row => row.includes(3))) {
                endGame(true);
            }
        }

        function checkGhostMilestones() {
            if (score >= 300 && milestoneReached < 300) {
                ghosts.push({ x: 9 * TILE, y: 5 * TILE, dirX: 1, dirY: 0, color: '#FFB8FF', baseColor: '#FFB8FF', speed: 2, isScared: false });
                milestoneReached = 300;
            }
            if (score >= 500 && milestoneReached < 500) {
                ghosts.push({ x: 9 * TILE, y: 5 * TILE, dirX: -1, dirY: 0, color: '#00FFFF', baseColor: '#00FFFF', speed: 2, isScared: false });
                milestoneReached = 500;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[r].length; c++) {
                    if (map[r][c] === 1) {
                        ctx.fillStyle = '#1919A6'; ctx.fillRect(c * TILE + 2, r * TILE + 2, TILE - 4, TILE - 4);
                    } else if (map[r][c] === 0) {
                        ctx.fillStyle = '#FFB8AE'; ctx.beginPath(); ctx.arc(c * TILE + TILE/2, r * TILE + TILE/2, 2, 0, Math.PI*2); ctx.fill();
                    } else if (map[r][c] === 3) {
                        if (Math.floor(Date.now() / 200) % 2 === 0) {
                            ctx.fillStyle = '#FFB8AE'; ctx.beginPath(); ctx.arc(c * TILE + TILE/2, r * TILE + TILE/2, 6, 0, Math.PI*2); ctx.fill();
                        }
                    }
                }
            }
            ghosts.forEach(g => {
                ctx.fillStyle = g.isScared ? ((powerModeTimer < 100 && Math.floor(Date.now()/100)%2===0)?'#FFF':'#2121FF') : g.baseColor;
                ctx.beginPath(); ctx.arc(g.x + TILE/2, g.y + TILE/2, TILE/2 - 2, Math.PI, 0);
                ctx.lineTo(g.x + TILE - 2, g.y + TILE - 2); ctx.lineTo(g.x + 2, g.y + TILE - 2); ctx.fill();
            });
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            const mouth = Math.abs(Math.sin(Date.now() / 150)) * 0.4;
            let rot = (pacman.dirX === 1) ? 0 : (pacman.dirX === -1) ? Math.PI : (pacman.dirY === -1) ? -Math.PI/2 : Math.PI/2;
            ctx.moveTo(pacman.x + TILE/2, pacman.y + TILE/2);
            ctx.arc(pacman.x + TILE/2, pacman.y + TILE/2, TILE/2 - 1, rot + mouth, rot + (2 * Math.PI - mouth));
            ctx.fill();
        }

        function endGame(win) {
            isGameOver = true;
            if (win) {
                if (currentLevelIndex < allLevels.length - 1) {
                    statusTitle.innerText = "Level " + (currentLevelIndex + 1) + " Clear!";
                    actionBtn.innerText = "進入下一關";
                } else {
                    statusTitle.innerText = "ALL LEVELS CLEAR!";
                    actionBtn.innerText = "重新遊戲";
                }
            } else {
                statusTitle.innerText = "GAME OVER";
                actionBtn.innerText = "重新開始";
            }
            overlay.style.display = 'block';
        }

        function nextLevelOrRestart() {
            if (statusTitle.innerText.includes("GAME OVER") || statusTitle.innerText.includes("ALL LEVELS")) {
                currentLevelIndex = 0; score = 0; scoreText.innerText = 0;
            } else {
                currentLevelIndex++;
            }
            initLevel(currentLevelIndex);
        }

        initLevel(0);
        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        gameLoop();
    </script>
</body>
</html>